# Artifact: Scheduling the Construction and Interrogation of Scope Graphs Using Attribute Grammars

## TODOs

- Place translator Silver project in here. Currently the scripts compile the
  translator by `./../statix_translate/compile`.

- `ministatixtest`/`ocamltest`/`silvertest` should communicate results with one
  another - perhaps `ministatixtest` communicates its own result to `ocamltest`
  and `silvertest` for a given input term. Then the two latter scripts verify
  that their result is the same.

- Enumerate test cases/results in the scripts - print out something like 
  `[n/m] of the tests passed, [m-n/m] tests failed`.

## Abstract

Recognizing that name binding, matching name references to
their declarations, is often done in an ad-hoc manner, Visser
and his colleagues introduced scope graphs as a uniform
representation of a programâ€™s static binding structure along
with a generic means for interrogating that representation
to resolve name references to their declarations. A challenge
arises in scheduling the construction and querying actions so
that a name resolution is not performed before all requisite
information for that resolution is added to the scope graph.
For example the name of a module to be imported must
be resolved, and that resolution added to the scope graph,
before names that may depend on that imported module
are resolved. Visser et al. introduced a notion of weakly
critical edges to constrain the order in which name resolution
queries are performed to a correct one, but this has been
found to be somewhat restrictive.

Visser et al. also introduced Statix, a constraint solving
language for scope graph-based name resolution. We show
that specifications written in an annotated version of Statix
can be translated into reference attribute grammars, and that
the order in which equations are solved under demand driven
evaluation provides a valid order for solving constraints in
Statix. This formalizes what has been folklore in the attribute
grammar community for some time, that scope graphs are
naturally specified in reference attributes grammars.

## Artifact structure

- `load-and-test`:
  Takes as argument a specification in our version of Statix, translates it to
  a Ministatix specification, an OCaml attribute grammar and a Silver attribute
  grammar, and then runs all test cases in `lm-specs/testcases` for each
  system. E.g. `./load-and-test lm-specs/lm-rec.mstx lm-specs/testcases/`.
  Each directory under the second argument must provide:
  - `input.aterm`: The test case written for Ministatix.
  - `ag_test.ml`: The test case written for the OCaml AG system.
  - `Main.sv`: The test case written for the Silver AG system.

- `all-tests`:
  Takes as argument a directory containing a program test case encoded for 
  Ministatix, the OCaml AG, and Silver AG. 
  Calls `one-test` for every directory under `lm-specs/testcases`. Run all
  input program terms for each system.

- `one-test`:
  Takes as argument a directory containing a program test case encoded for 
  Ministatix, the OCaml AG, and Silver AG. Evaluates that term test case under 
  each system. E.g. `./one-test lm-specs/testcases/simple_add`.

- `ministatixtest`:
  Takes as argument a directory containing a program test case encoded for 
  Ministatix, the OCaml AG, and Silver AG. 
  Run an input program through the Ministatix evaluator.

- `ocamltest`:
  Takes as argument a directory containing a program test case encoded for 
  Ministatix, the OCaml AG, and Silver AG. 
  Run an input program through the OCaml AG evaluator.

- `silvertest`:
  Takes as argument a directory containing a program test case encoded for 
  Ministatix, the OCaml AG, and Silver AG. 
  Run an input program through the Silver AG evaluator.

- `lm-specs/`
  - `lm-par.mstx`: An example specification defining LM with parallel imports.
  - `lm-rec.mstx`: An example specification defining LM with recursive imports.
  - `lm-seq.mstx`: An example specification defining LM with sequential imports.
  - `testcases/`: Program test cases encoded in the input format for the three
                  evaluators.

- `silverstuff/`:
  - `compile`: Compile the grammar under `statix_trans/`.
  - `statix_trans/`: Template grammar for translated Statix specifications. This
    is where the `Main.sv` program test case and `Spec_*.sv` Silver generated
    attribute grammar go when running tests.

- `ocaml_lib/`:
  - `ocaml_ag_syntax.ml`:
    Syntax of our OCaml attribute grammar system.
  - `ocaml_ag_spec.mli`:
     Signature for AG specifications generated by the translator.
  - `ocaml_ag_eval.ml`: 
    The evaluation system for our OCaml AG implementation.

- `ministatix.hs/`: Ministatix artifact as presented in KWTA.

## Execution

### Executing multiple test cases for a given specification

#### Pre-written test cases

For each Statix specification, e.g. `lm-specs/lm-rec.mstx`:

1. Execute `./loadspec lm-specs/lm-rec.mstx` to generate the Ministatix, OCaml
   AG, and Silver AG specifications, and evaluate all test cases in. 
   `lm-specs/testcases`.

2. Verify that the result (Satisfiable/Unsatisfiable/Stuck) is consistent between
   the Ministatix, OCaml and Silver results. Note that we expect the result under
   both AGs to be "Cycle detected" when the Ministatix result is "Stuck".

#### Your own test cases

For writing specifications not provided in this artifact, you will need to write
a file `my-spec.mstx` in our syntax for translating, as well as your own 
test cases for the three evaluator systems, written as abstract terms satisfying
your specification's syntax definition.

Your program test cases should be directories of the form:
- `my-testcases/`
  - `my-testcase/`
    - `input.aterm`: The test case written for Ministatix.
    - `ag_test.ml`: The test case written for the OCaml AG system.
    - `Main.sv`: The test case written for the Silver AG system.
  - ...

Then load and run as follows:

1. Execute `./loadspec path/to/my-spec.mstx path/to/my-testcases` to generate 
   the Ministatix, OCaml AG, and Silver AG specifications, and evaluate all test
   cases in directory `path/to/my-testcases`.

2. Verify that the result (Satisfiable/Unsatisfiable/Stuck) is consistent between
   the Ministatix, OCaml and Silver results. Note that we expect the result under
   both AGs to be "Cycle detected" when the Ministatix result is "Stuck".

### Executing one test case for a given specification

...