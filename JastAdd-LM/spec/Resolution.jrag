import java.util.*;

aspect Resolution {

  syn lazy DFA Ref.dfa();

  eq Ref.dfa() {
    SinkState sink = new SinkState();
    return new DFA(sink);
  }

  /*---------- ModRef ----------*/

  eq RefImport.dfa() {

    // LEX* IMP? MOD
    
    State state0 = new State();
    State state1 = new State();
    FinalState state2 = new FinalState();
    SinkState sink = new SinkState();

    state0.setId(0);
    state0.setLexTrans(state0);
    state0.setImpTrans(state1);
    state0.setModTrans(state2);
    state0.setVarTrans(sink);

    state1.setId(1);
    state1.setLexTrans(sink);
    state1.setImpTrans(sink);
    state1.setModTrans(state2);
    state1.setVarTrans(sink);

    state2.setId(2);
    state2.setLexTrans(sink);
    state2.setImpTrans(sink);
    state2.setModTrans(sink);
    state2.setVarTrans(sink);

    sink.setId(-1);
    sink.setLexTrans(sink);
    sink.setImpTrans(sink);
    sink.setModTrans(sink);
    sink.setVarTrans(sink);

    state0.setFinal(false);
    state1.setFinal(false);
    state2.setFinal(true);
    sink.setFinal(false);

    return new DFA(state0);

  }


  /*---------- VarRef ----------*/

  eq RefSimple.dfa() {

    // LEX* IMP? VAR
    
    State state0 = new State();
    State state1 = new State();
    FinalState state2 = new FinalState();
    SinkState sink = new SinkState();

    state0.setId(0);
    state0.setLexTrans(state0);
    state0.setImpTrans(state1);
    state0.setModTrans(sink);
    state0.setVarTrans(state2);

    state1.setId(1);
    state1.setLexTrans(sink);
    state1.setImpTrans(sink);
    state1.setModTrans(sink);
    state1.setVarTrans(state2);

    state2.setId(2);
    state2.setLexTrans(sink);
    state2.setImpTrans(sink);
    state2.setModTrans(sink);
    state2.setVarTrans(sink);

    sink.setId(-1);
    sink.setLexTrans(sink);
    sink.setImpTrans(sink);
    sink.setModTrans(sink);
    sink.setVarTrans(sink);

    state0.setFinal(false);
    state1.setFinal(false);
    state2.setFinal(true);
    sink.setFinal(false);

    return new DFA(state0);

  }


  /*---------- DFA/State ----------*/

  syn /*lazy*/ ArrayList<Scope> DFA.resolve(String id, Scope currentScope);
  eq DFA.resolve(String id, Scope currentScope) = getStart().resolve(id, currentScope);

  syn /*lazy*/ ArrayList<Scope> State.resolve(String id, Scope currentScope);

  eq State.resolve(String id, Scope currentScope) {

    System.out.println(Scope.indent() + "At state " + Integer.toString(getId()) + " looking for \"" + id + "\" in scope " + currentScope.getName());
    
    ArrayList<Scope> varTrans = new ArrayList<Scope>();
    Scope.subResCount++;
    System.out.println(Scope.indent() + "Checking for VAR edges from " + currentScope.getName());
    for (Scope s: currentScope.varScopes()) {
      if (getVarTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following a VAR edge to state " + Integer.toString(getVarTrans().getId()));
      Scope.subResCount++;
      varTrans.addAll(getVarTrans().resolve(id, s));
      Scope.subResCount -= 2;
    }
    //if (!varTrans.isEmpty()) {Scope.subResCount--; return varTrans;}


    ArrayList<Scope> modTrans = new ArrayList<Scope>();
    System.out.println(Scope.indent() + "Checking for MOD edges from " + currentScope.getName());
    for (Scope s: currentScope.modScopes()) {
      if (getModTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following a MOD edge to state " + Integer.toString(getModTrans().getId()));
      Scope.subResCount++;
      modTrans.addAll(getModTrans().resolve(id, s)); 
      Scope.subResCount -= 2;
    }
    //if (!modTrans.isEmpty()) {Scope.subResCount--; return modTrans;}


    ArrayList<Scope> impTrans = new ArrayList<Scope>();
    System.out.println(Scope.indent() + "Checking for IMP edges from " + currentScope.getName());
    for (Scope s: currentScope.impScopes()) { 
      if (getImpTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following an IMP edge to state " + Integer.toString(getImpTrans().getId()));
      Scope.subResCount++;
      impTrans.addAll(getImpTrans().resolve(id, s)); 
      Scope.subResCount -= 2;
    }
    //if (!impTrans.isEmpty()) {Scope.subResCount--; return impTrans;}


    ArrayList<Scope> lexTrans = new ArrayList<Scope>();
    System.out.println(Scope.indent() + "Checking for LEX edges from " + currentScope.getName());
    for (Scope s: currentScope.lexScopes()) {
      if (getLexTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following a LEX edge to state " + Integer.toString(getLexTrans().getId()));
      Scope.subResCount++;
      lexTrans.addAll(getLexTrans().resolve(id, s)); 
      Scope.subResCount -= 2;
    }
    //if (!lexTrans.isEmpty()) {Scope.subResCount--; return lexTrans;}
    Scope.subResCount--;

    ArrayList<Scope> res = varTrans;
    res.addAll(modTrans);
    res.addAll(impTrans);
    res.addAll(lexTrans);

    return res;//new ArrayList<Scope>();

  }

  eq FinalState.resolve(String id, Scope currentScope) {
    //System.out.println("Hm.");

    System.out.print(Scope.indent() + "At FINAL state " + Integer.toString(getId()) + " looking for \"" + id + "\" in scope " + currentScope.getName());

    //System.out.println("Trve");
    
    ArrayList<Scope> result = new ArrayList<Scope>();

    ScopeDatum thisScope = (ScopeDatum) currentScope;

    if (currentScope instanceof ScopeDatum &&
        ((ScopeDatum) currentScope).getDatum().getId().equals(id)) {
      result.add(currentScope);
      System.out.println(". Datum is \"" + ((ScopeDatum) currentScope).getDatum().getId() +  "\". This res is good. Adding it to the list.");
    } else {
      System.out.println(". Datum is \"" + ((ScopeDatum) currentScope).getDatum().getId() +  "\". This res is not good.");
    }

    return result;

  }

  eq SinkState.resolve(String id, Scope currentScope) {
    System.out.println(Scope.indent() + "At the sink state. Nothing to do or return.");
    return new ArrayList<Scope>();
  }

  /*---------- Ref ----------*/

  syn lazy ArrayList<Scope> Ref.res();// circular [new ArrayList<Scope>()];

  eq RefSimple.res() {

    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }

    System.out.println(Scope.indent() + "Beginning resolution of " + getId() + "\"");

    Scope.subResCount++;

    ArrayList<Scope> res = dfa().resolve(getId(), getScope());

    Scope.subResCount--;

    System.out.print(Scope.indent() + "Ending resolution of \"" + getId() + "\". Found : [");
    for (Scope s: res) {
      System.out.print("\"" + s.getName() + "\", ");
    }
    System.out.println("].");

    return res;
  }

  eq RefImport.res() {

    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }

    System.out.print(Scope.indent() + "Beginning resolution of \"" + getId() + "\". Current res value is : [");
    for (Scope s: getScope().getCurrentImpScopesValue()) {
      System.out.print("\"" + s.getName() + "\", ");
    }
    System.out.println("].");

    Scope.subResCount++;

    ArrayList<Scope> res = dfa().resolve(getId(), getScope());

    Scope.subResCount--;

    System.out.print(Scope.indent() + "Ending resolution of \"" + getId() + "\". Found : [");
    for (Scope s: res) {
      System.out.print("\"" + s.getName() + "\", ");
    }
    System.out.println("].");

    return res;
  }

}