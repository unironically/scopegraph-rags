import java.util.*;

aspect Resolution {

  /*---------- DFA ----------*/

  syn ArrayList<Scope> DFA.decls(Ref ref, Scope current);

  eq DFA.decls(Ref ref, Scope current) = stateLex().decls(ref, current);

  syn FinalState DFA.finalState();
  syn StinkState DFA.sinkState();

  eq DFA.finalState() { State fin = new FinalState();
                        fin.setParent(this); return fin; }

    eq DFA.sinkState()  { State snk = new FinalState();
                        snk.setParent(this); return snk; }

  eq DFA.finalState().lexT() { return this.sinkState(); }
  eq DFA.finalState().impT() { return this.sinkState(); }
  eq DFA.finalState().varT() { return this.sinkState(); }
  eq DFA.finalState().modT() { return this.sinkState(); }

  eq DFA.sinkState().lexT() { return this.sinkState(); }
  eq DFA.sinkState().impT() { return this.sinkState(); }
  eq DFA.sinkState().varT() { return this.sinkState(); }
  eq DFA.sinkState().modT() { return this.sinkState(); }

  /*---------- VarDFA ----------*/

  syn State VarDFA.lexState();
  syn State VarDFA.impState();

  eq VarDFA.lexState() { State lex = new State();
                         lex.setParent(this); return lex; }
  eq VarDFA.impState() { State imp = new State();
                         imp.setParent(this); return imp; }
  
  eq VarDFA.lexState().lexT() { return this.lexState(); }
  eq VarDFA.lexState().impT() { return this.impState(); }
  eq VarDFA.lexState().varT() { return this.finalState(); }
  eq VarDFA.lexState().modT() { return this.sinkState(); }

  eq VarDFA.impState().lexT() { return this.sinkState(); }
  eq VarDFA.impState().impT() { return this.sinkState(); }
  eq VarDFA.impState().varT() { return this.finalState(); }
  eq VarDFA.impState().modT() { return this.sinkState(); }

  /*---------- ModDFA ----------*/

  syn State VarDFA.lexState();
  syn State VarDFA.impState();

  eq VarDFA.lexState() { State lex = new ModState();
                         lex.setParent(this); return lex; }
  eq VarDFA.impState() { State imp = new ModState();
                         imp.setParent(this); return imp; }

  eq VarDFA.lexState().lexT() { return this.lexState(); }
  eq VarDFA.lexState().impT() { return this.impState(); }
  eq VarDFA.lexState().varT() { return this.sinkState(); }
  eq VarDFA.lexState().modT() { return this.finalState(); }

  eq VarDFA.impState().lexT() { return this.sinkState(); }
  eq VarDFA.impState().impT() { return this.sinkState(); }
  eq VarDFA.impState().varT() { return this.sinkState(); }
  eq VarDFA.impState().modT() { return this.finalState(); }
  
  /*---------- State ----------*/

  inh State State.lexT();
  inh State State.impT();
  inh State State.varT();
  inh State State.modT();

  syn ArrayList<Scope> State.decls(Ref ref, Scope s);

  eq VarState.decls(Ref ref, Scope s) {
    
    ArrayList<Scope> varRes = new ArrayList<Scope>();

    for (Scope s: s.getVar()) {
      varRes.addAll(this.varT().decls(ref, s));
    }

    ArrayList<Scope> modRes = new ArrayList<Scope>();

    for (Scope s: s.getMod()) {
      modRes.addAll(this.modT().decls(ref, s));
    }

    ArrayList<Scope> impRes = new ArrayList<Scope>();

    for (Scope s: s.getImp()) {
      impRes.addAll(this.impT().decls(ref, s));
    }

    ArrayList<Scope> lexRes = new ArrayList<Scope>();

    for (Scope s: s.getLex()) {
      lexRes.addAll(this.lexT().decls(ref, s));
    }

    ArrayList<Scope> allRes = new ArrayList<Scope>();

    allRes.addAll(varRes);
    allRes.addAll(modRes);
    allRes.addAll(impRes);
    allRes.addAll(lexRes);

    return allRes;

  }

  eq ModState.decls(Ref ref, Scope s) {
    
    ArrayList<Scope> varRes = new ArrayList<Scope>();

    for (Scope s: s.getVar()) {
      varRes.addAll(this.varT().decls(ref, s));
    }

    ArrayList<Scope> modRes = new ArrayList<Scope>();

    for (Scope s: s.getMod()) {
      modRes.addAll(this.modT().decls(ref, s));
    }

    ArrayList<Scope> impTentativeRes = new ArrayList<Scope>();

    for (Scope s: s.getImpTentative()) {
      impTentativeRes.addAll(this.impT().decls(ref, s));
    }

    ArrayList<Scope> lexRes = new ArrayList<Scope>();

    for (Scope s: s.getLex()) {
      lexRes.addAll(this.lexT().decls(ref, s));
    }

    ArrayList<Scope> allRes = new ArrayList<Scope>();

    allRes.addAll(varRes);
    allRes.addAll(modRes);
    allRes.addAll(impTentativeRes);
    allRes.addAll(lexRes);

    return allRes;

  }
  
  eq FinalState.findVisMod(Ref ref, Scope s) {

    ArrayList<Scope> res = new ArrayList<Scope>();

    if (s.datum().str().equals(ref.str())) {
      res.add(s);
    }

    return res;

  }


  eq SinkState.findVisMod(Ref ref, Scope s) {

    return new ArrayList<Scope>();

  }


  /*---------- VarRef ----------*/

  syn lazy ArrayList<Scope> VarRef.varRes();

  // top.varRes = top.dfa.decls(top, head(top.lex))
  eq VarRef.varRes() { return getDFA().decls(this, this.lex().get(0)); }


  /*---------- ModRef ----------*/

  syn ArrayList<Scope> ModRef.modRes()
    circular [new ArrayList<Scope>()];

  // top.modRes = top.dfa.decls(top, head(top.lex))
  eq ModRef.modRes() { return getDFA().decls(this, this.lex().get(0)); }

}