import java.util.*;

aspect Resolution {


  /*---------- DFA/State ----------*/

  syn lazy ArrayList<ArrayList<Scope>> DFA.resolve(String id, Scope currentScope);
  syn lazy ArrayList<ArrayList<Scope>> State.resolve(String id, Scope currentScope);
  eq DFA.resolve(String id, Scope currentScope) = getStart().resolve(id, currentScope);

  eq State.resolve(String id, Scope currentScope) {
    
    ArrayList<ArrayList<Scope>> allRes = new ArrayList<ArrayList<Scope>>();


    ArrayList<Scope> varRes = new ArrayList<Scope>();
    for (Scope s: currentScope.varScopes()) {
      if (getVarTrans().getId() == -1) continue;
      ArrayList<ArrayList<Scope>> varResInter = getVarTrans().resolve(id, s);
      if (!varResInter.isEmpty()) varRes.addAll(varResInter.get(0));
    }
    if (!varRes.isEmpty()) allRes.add(varRes);


    ArrayList<Scope> modRes = new ArrayList<Scope>();
    for (Scope s: currentScope.modScopes()) {
      if (getModTrans().getId() == -1) continue;
      ArrayList<ArrayList<Scope>> modResInter = getModTrans().resolve(id, s);
      if (!modResInter.isEmpty()) modRes.addAll(modResInter.get(0));
    }
    if (!modRes.isEmpty()) allRes.add(modRes);


    ArrayList<Scope> impRes = new ArrayList<Scope>();
    for (Scope s: currentScope.impScopes()) {
      if (getImpTrans().getId() == -1) continue;
      ArrayList<ArrayList<Scope>> impResInter = getImpTrans().resolve(id, s);
      if (!impResInter.isEmpty()) impRes.addAll(impResInter.get(0));
    }
    if (!impRes.isEmpty()) allRes.add(impRes);


    ArrayList<Scope> lexRes = new ArrayList<Scope>();
    for (Scope s: currentScope.lexScopes()) {
      if (getLexTrans().getId() == -1) continue;
      ArrayList<ArrayList<Scope>> lexResInter = getLexTrans().resolve(id, s);
      if (!lexResInter.isEmpty()) lexRes.addAll(lexResInter.get(0));
    }
    if (!lexRes.isEmpty()) allRes.add(lexRes);

    return allRes;

  }

  eq FinalState.resolve(String id, Scope currentScope) {

    ArrayList<ArrayList<Scope>> result = new ArrayList<ArrayList<Scope>>();
    ArrayList<Scope> resultOne = new ArrayList<Scope>();

    ScopeDatum thisScope = (ScopeDatum) currentScope;
    
    if (thisScope.getDatum().getId().equals(id)) {
      resultOne.add(currentScope);
      result.add(resultOne);
    }

    return result;

  }


  eq SinkState.resolve(String id, Scope currentScope) {
    return new ArrayList<ArrayList<Scope>>();
  }


  /*---------- Ref ----------*/

  syn lazy ArrayList<Scope> Ref.decls();// circular [new ArrayList<Scope>()];

  eq Ref.decls() {

    //Opt resOpt = new Opt();
    //resOpt.setParent(this);

    ArrayList<Scope> myDecls = new ArrayList<Scope>();

    ArrayList<ArrayList<Scope>> res = getDFA().resolve(getId(), getScope());

        // No res         No res                  Ambiguous
    if (res.isEmpty() || res.get(0).isEmpty() || res.get(0).size() > 1) {
      //System.out.println("- No resolutions (1) found for reference " + getLabel());
      return myDecls;
    } else if (res.get(0).isEmpty()) {
      //System.out.println("- No resolutions (2) found for reference " + getLabel());
      return myDecls;
    } else if (res.get(0).size() > 1) {
      //System.out.println("- Ambiguous reference " + getLabel());
      return myDecls;
    }

    //System.out.println("fleeeeeeeeeeeeeehhhhhh " + getId());

    //resOpt.setChild(res.get(0).get(0), 0);

    myDecls.addAll(res.get(0));

    return myDecls;

  }

}


/*try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }*/