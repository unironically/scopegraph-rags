import java.util.*;

aspect Resolution {

  /*---------- DFA/State ----------*/

  syn lazy ArrayList<Scope> DFA.resolve(String id, Scope currentScope);
  eq DFA.resolve(String id, Scope currentScope) = getStart().resolve(id, currentScope);

  syn lazy ArrayList<Scope> State.resolve(String id, Scope currentScope);

  eq State.resolve(String id, Scope currentScope) {

    System.out.println(Scope.indent() + "At state " + Integer.toString(getId()) + " looking for \"" + id + "\" in scope " + currentScope.getName());
    
    ArrayList<Scope> res = new ArrayList<Scope>();

    Scope.subResCount++;
    System.out.println(Scope.indent() + "Checking for VAR edges from " + currentScope.getName());
    for (Scope s: currentScope.varScopes()) {
      if (getVarTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following a VAR edge to state " + Integer.toString(getVarTrans().getId()));
      Scope.subResCount++;
      res.addAll(getVarTrans().resolve(id, s));
      Scope.subResCount -= 2;
    }

    System.out.println(Scope.indent() + "Checking for MOD edges from " + currentScope.getName());
    for (Scope s: currentScope.modScopes()) {
      if (getModTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following a MOD edge to state " + Integer.toString(getModTrans().getId()));
      Scope.subResCount++;
      res.addAll(getModTrans().resolve(id, s));
      Scope.subResCount -= 2;
    }

    System.out.println(Scope.indent() + "Checking for IMP edges from " + currentScope.getName());
    for (Scope s: currentScope.impScopes()) {
      if (getImpTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following an IMP edge to state " + Integer.toString(getImpTrans().getId()));
      Scope.subResCount++;
      res.addAll(getImpTrans().resolve(id, s));
      Scope.subResCount -= 2;
    }

    System.out.println(Scope.indent() + "Checking for LEX edges from " + currentScope.getName());
    for (Scope s: currentScope.lexScopes()) {
      if (getLexTrans().getId() == -1) continue;
      Scope.subResCount++;
      System.out.println(Scope.indent() + "Following a LEX edge to state " + Integer.toString(getLexTrans().getId()));
      Scope.subResCount++;
      res.addAll(getLexTrans().resolve(id, s));
      Scope.subResCount -= 2;
    }

    Scope.subResCount--;

    return res;

  }

  eq FinalState.resolve(String id, Scope currentScope) {

    System.out.print(Scope.indent() + "At FINAL state " + Integer.toString(getId()) + " looking for \"" + id + "\" in scope " + currentScope.getName());
    
    ArrayList<Scope> result = new ArrayList<Scope>();

    ScopeDatum thisScope = (ScopeDatum) currentScope;

    if (currentScope instanceof ScopeDatum &&
        ((ScopeDatum) currentScope).getDatum().getId().equals(id)) {
      result.add(currentScope);
      System.out.println(". Datum is \"" + ((ScopeDatum) currentScope).getDatum().getId() +  "\". This res is good. Adding it to the list.");
    } else {
      System.out.println(". Datum is \"" + ((ScopeDatum) currentScope).getDatum().getId() +  "\". This res is not good.");
    }

    return result;

  }

  eq SinkState.resolve(String id, Scope currentScope) {
    System.out.println(Scope.indent() + "At the sink state. Nothing to do or return.");
    return new ArrayList<Scope>();
  }


  /*---------- Ref ----------*/

  syn lazy ArrayList<Scope> Ref.res();// circular [new ArrayList<Scope>()];

  eq Ref.res() {

    Scope.refResolvingOrDone = true;

    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }

    System.out.println(Scope.indent() + "Beginning resolution of \"" + getId() + "\"");

    Scope.subResCount++;

    ArrayList<Scope> res = getDFA().resolve(getId(), getScope());

    Scope.subResCount--;

    System.out.print(Scope.indent() + "Ending resolution of \"" + getId() + "\". Found : [");
    for (Scope s: res) {
      System.out.print("\"" + s.getName() + "\", ");
    }
    System.out.println("].");

    Scope.refResolvingOrDone = false;

    return res;

  }

}