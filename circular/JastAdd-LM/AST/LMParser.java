// Generated from /home/luke/Academia/personal/scopegraph-rags/circular/JastAdd-LM/AST/LMParser.all
package AST;
import AST.*; 
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.4
 * from the grammar specification "LMParser.beaver".
 */
public class LMParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short MODULE = 1;
		static public final short IDENTIFIER = 2;
		static public final short LBRACE = 3;
		static public final short RBRACE = 4;
		static public final short COLON = 5;
		static public final short ASSIGN = 6;
		static public final short IMPORT = 7;
		static public final short DEF = 8;
		static public final short INTEGER = 9;
		static public final short TRUE = 10;
		static public final short FALSE = 11;
		static public final short PLUS = 12;
		static public final short AND = 13;
		static public final short INTTY = 14;
		static public final short BOOLTY = 15;

		static public final String[] NAMES = {
			"EOF",
			"MODULE",
			"IDENTIFIER",
			"LBRACE",
			"RBRACE",
			"COLON",
			"ASSIGN",
			"IMPORT",
			"DEF",
			"INTEGER",
			"TRUE",
			"FALSE",
			"PLUS",
			"AND",
			"INTTY",
			"BOOLTY"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obKSjE0a4GB7ON144UorF5T#BPu0yO4uyQZnglHaySF1YZc93u2twd0eg82hGrFMHP3CQ" +
		"3MwcQhgxPtimi7gL3l14T4LLrYA60ag5qYG#YYuHHwp2dcUdtYNUYZvHHwv0C#ZtYcUWXOz" +
		"Gwf8D#cnWXActaP6GSvh40N#SFY2zY8A#grhM8Jw8bBwhMSGQWhB8sCmohMCGIbhcwy8BQh" +
		"YuS6TfQXl947qSMQrZ1Al8eeenrLCO08agFwl7qSQM35BzXECczKExEo9rGNlWZByx8yw4y" +
		"zYEBXR9Vko9AP#eS2TvMaciMkQ2sg#bWN7ky4#EZd9b6Xd$9eZJ6HbDmpdGVJRvHmGNt7c4" +
		"BnpZ5BixmW0OESCbvTSw$uYoVTxo97THmY1FSO8yJwcPAKmnmhLfMtLQjaRVa7TcmkoR0FV" +
		"d$n#Sv8thkdDv9b7IKFllJT9LvreP5xYtI5rYNoCetFdNaim==");
 // Generated from /home/luke/Academia/personal/scopegraph-rags/circular/JastAdd-LM/AST/LMParser.all
class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new Error(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new Error(s.toString());
    }
  }
  { report = new Events(); } // Use error handler in parser

	public LMParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = decls.decls
			{
					final Symbol _symbol_decls = _symbols[offset + 1];
					final Decls decls = (Decls) _symbol_decls.value;
					 ASTNode _node_ = new Program(decls);
        _node_.setStart(Symbol.getLine(_symbol_decls.getStart()), (short) Symbol.getColumn(_symbol_decls.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_decls.getEnd()), (short) Symbol.getColumn(_symbol_decls.getEnd()));
        return new Symbol(_node_);
			}
			case 1: // decls = 
			{
					 return new Symbol(new DeclsNil());
			}
			case 2: // decls = decl.decl decls.decls
			{
					final Symbol _symbol_decl = _symbols[offset + 1];
					final Decl decl = (Decl) _symbol_decl.value;
					final Symbol _symbol_decls = _symbols[offset + 2];
					final Decls decls = (Decls) _symbol_decls.value;
					 ASTNode _node_ = new DeclsCons(decl, decls);
        _node_.setStart(Symbol.getLine(_symbol_decl.getStart()), (short) Symbol.getColumn(_symbol_decl.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_decls.getEnd()), (short) Symbol.getColumn(_symbol_decls.getEnd()));
        return new Symbol(_node_);
			}
			case 3: // decl = MODULE.MODULE IDENTIFIER.IDENTIFIER LBRACE.LBRACE decls.decls RBRACE.RBRACE
			{
					final Symbol MODULE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol LBRACE = _symbols[offset + 3];
					final Symbol _symbol_decls = _symbols[offset + 4];
					final Decls decls = (Decls) _symbol_decls.value;
					final Symbol RBRACE = _symbols[offset + 5];
					 ASTNode _node_ = new ModuleDecl(((String)IDENTIFIER.value), decls);
        _node_.setStart(Symbol.getLine(MODULE.getStart()), (short) Symbol.getColumn(MODULE.getStart()));
        _node_.setEnd(Symbol.getLine(RBRACE.getEnd()), (short) Symbol.getColumn(RBRACE.getEnd()));
        return new Symbol(_node_);
			}
			case 4: // decl = IMPORT.IMPORT mod_ref.mod_ref
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_mod_ref = _symbols[offset + 2];
					final ModRef mod_ref = (ModRef) _symbol_mod_ref.value;
					 ASTNode _node_ = new ImportDecl(mod_ref);
        _node_.setStart(Symbol.getLine(IMPORT.getStart()), (short) Symbol.getColumn(IMPORT.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_mod_ref.getEnd()), (short) Symbol.getColumn(_symbol_mod_ref.getEnd()));
        return new Symbol(_node_);
			}
			case 5: // decl = DEF.DEF par_bind.par_bind
			{
					final Symbol DEF = _symbols[offset + 1];
					final Symbol _symbol_par_bind = _symbols[offset + 2];
					final ParBind par_bind = (ParBind) _symbol_par_bind.value;
					 ASTNode _node_ = new DefDecl(par_bind);
        _node_.setStart(Symbol.getLine(DEF.getStart()), (short) Symbol.getColumn(DEF.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_par_bind.getEnd()), (short) Symbol.getColumn(_symbol_par_bind.getEnd()));
        return new Symbol(_node_);
			}
			case 6: // expr = var_ref.var_ref
			{
					final Symbol _symbol_var_ref = _symbols[offset + 1];
					final VarRef var_ref = (VarRef) _symbol_var_ref.value;
					 ASTNode _node_ = new VarExpr(var_ref);
        _node_.setStart(Symbol.getLine(_symbol_var_ref.getStart()), (short) Symbol.getColumn(_symbol_var_ref.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_var_ref.getEnd()), (short) Symbol.getColumn(_symbol_var_ref.getEnd()));
        return new Symbol(_node_);
			}
			case 7: // expr = INTEGER.INTEGER
			{
					final Symbol INTEGER = _symbols[offset + 1];
					 ASTNode _node_ = new IntExpr(Integer.valueOf(((String)INTEGER.value)));
        _node_.setStart(Symbol.getLine(INTEGER.getStart()), (short) Symbol.getColumn(INTEGER.getStart()));
        _node_.setEnd(Symbol.getLine(INTEGER.getEnd()), (short) Symbol.getColumn(INTEGER.getEnd()));
        return new Symbol(_node_);
			}
			case 8: // expr = TRUE.TRUE
			{
					final Symbol TRUE = _symbols[offset + 1];
					 ASTNode _node_ = new BoolExpr(true);
        _node_.setStart(Symbol.getLine(TRUE.getStart()), (short) Symbol.getColumn(TRUE.getStart()));
        _node_.setEnd(Symbol.getLine(TRUE.getEnd()), (short) Symbol.getColumn(TRUE.getEnd()));
        return new Symbol(_node_);
			}
			case 9: // expr = FALSE.FALSE
			{
					final Symbol FALSE = _symbols[offset + 1];
					 ASTNode _node_ = new BoolExpr(false);
        _node_.setStart(Symbol.getLine(FALSE.getStart()), (short) Symbol.getColumn(FALSE.getStart()));
        _node_.setEnd(Symbol.getLine(FALSE.getEnd()), (short) Symbol.getColumn(FALSE.getEnd()));
        return new Symbol(_node_);
			}
			case 10: // expr = expr.a PLUS.PLUS expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 ASTNode _node_ = new AddExpr(a, b);
        _node_.setStart(Symbol.getLine(_symbol_a.getStart()), (short) Symbol.getColumn(_symbol_a.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_b.getEnd()), (short) Symbol.getColumn(_symbol_b.getEnd()));
        return new Symbol(_node_);
			}
			case 11: // expr = expr.a AND.AND expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 ASTNode _node_ = new AndExpr(a, b);
        _node_.setStart(Symbol.getLine(_symbol_a.getStart()), (short) Symbol.getColumn(_symbol_a.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_b.getEnd()), (short) Symbol.getColumn(_symbol_b.getEnd()));
        return new Symbol(_node_);
			}
			case 12: // type = INTTY.INTTY
			{
					final Symbol INTTY = _symbols[offset + 1];
					 ASTNode _node_ = new IntType();
        _node_.setStart(Symbol.getLine(INTTY.getStart()), (short) Symbol.getColumn(INTTY.getStart()));
        _node_.setEnd(Symbol.getLine(INTTY.getEnd()), (short) Symbol.getColumn(INTTY.getEnd()));
        return new Symbol(_node_);
			}
			case 13: // type = BOOLTY.BOOLTY
			{
					final Symbol BOOLTY = _symbols[offset + 1];
					 ASTNode _node_ = new BoolType();
        _node_.setStart(Symbol.getLine(BOOLTY.getStart()), (short) Symbol.getColumn(BOOLTY.getStart()));
        _node_.setEnd(Symbol.getLine(BOOLTY.getEnd()), (short) Symbol.getColumn(BOOLTY.getEnd()));
        return new Symbol(_node_);
			}
			case 14: // par_bind = IDENTIFIER.IDENTIFIER COLON.COLON type.type ASSIGN.ASSIGN expr.expr
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_type = _symbols[offset + 3];
					final Type type = (Type) _symbol_type.value;
					final Symbol ASSIGN = _symbols[offset + 4];
					final Symbol _symbol_expr = _symbols[offset + 5];
					final Expr expr = (Expr) _symbol_expr.value;
					 ASTNode _node_ = new ParBind(((String)IDENTIFIER.value), type, expr);
        _node_.setStart(Symbol.getLine(IDENTIFIER.getStart()), (short) Symbol.getColumn(IDENTIFIER.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_expr.getEnd()), (short) Symbol.getColumn(_symbol_expr.getEnd()));
        return new Symbol(_node_);
			}
			case 15: // par_bind = IDENTIFIER.IDENTIFIER ASSIGN.ASSIGN expr.expr
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_expr = _symbols[offset + 3];
					final Expr expr = (Expr) _symbol_expr.value;
					 ASTNode _node_ = new ParBind(((String)IDENTIFIER.value), new ErrType(), expr);
        _node_.setStart(Symbol.getLine(IDENTIFIER.getStart()), (short) Symbol.getColumn(IDENTIFIER.getStart()));
        _node_.setEnd(Symbol.getLine(_symbol_expr.getEnd()), (short) Symbol.getColumn(_symbol_expr.getEnd()));
        return new Symbol(_node_);
			}
			case 16: // mod_ref = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 ASTNode _node_ = new ModRef(((String)IDENTIFIER.value));
        _node_.setStart(Symbol.getLine(IDENTIFIER.getStart()), (short) Symbol.getColumn(IDENTIFIER.getStart()));
        _node_.setEnd(Symbol.getLine(IDENTIFIER.getEnd()), (short) Symbol.getColumn(IDENTIFIER.getEnd()));
        return new Symbol(_node_);
			}
			case 17: // var_ref = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 ASTNode _node_ = new VarRef(((String)IDENTIFIER.value));
        _node_.setStart(Symbol.getLine(IDENTIFIER.getStart()), (short) Symbol.getColumn(IDENTIFIER.getStart()));
        _node_.setEnd(Symbol.getLine(IDENTIFIER.getEnd()), (short) Symbol.getColumn(IDENTIFIER.getEnd()));
        return new Symbol(_node_);
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
