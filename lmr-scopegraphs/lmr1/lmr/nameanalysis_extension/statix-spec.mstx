import statixlib.paths
import statixlib.sets



main(p) :- p match {

    Program(ds):[] ->
      {glob}
        new glob,
        decls(glob, ds)
    
}.



decls(s, ds, s_module) :- ds match {
  
    DeclsNil() ->
      true
  
  | DeclsCons(d, ds) ->
      {seqScope}
        new seqScope,
        seqScope -[ `LEX ]-> s,
        decl(s, d, seqScope, s_module),
        decls(s, ds, s_module)

}.



decl (s, d, s_def, s_module) :- d match {

  DeclModule(x, ds)  -> 
      {modScope, x}
          new modScope -> DatumMod(x, modScope),
          modScope -[ `LEX ]-> s,
          s_module -[ `MOD ]-> modScope,
          decls(modScope, ds)

  | DeclImport(r)  -> 
      mod-ref(s, r, s_def)

  | DeclDef(b)  -> 
      par-bind(s, b, s_module)

  }.



expr(s, e, ty) :- e match {
    
    ExprInt(_) ->
      ty == INT()

  | ExprTrue() ->
      ty == BOOL()

  | ExprFalse() ->
      ty == BOOL()

  | ExprVar(r) -> 
      var-ref(s, r, ref_ty),
      ty == ref_ty

  | ExprAdd(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == INT(),
        ty2 == INT(),
        ty == INT()

  | ExprSub(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == INT(),
        ty2 == INT(),
        ty == INT()


  | ExprMul(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == INT(),
        ty2 == INT(),
        ty == INT()


  | ExprDiv(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == INT(),
        ty2 == INT(),
        ty == INT()


  | ExprAnd(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == BOOL(),
        ty2 == BOOL(),
        ty == BOOL()


  | ExprOr(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == BOOL(),
        ty2 == BOOL(),
        ty == BOOL()

  | ExprEq(e1, e2) ->
      {ty1, ty2}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == ty2,
        ty == BOOL()

  | ExprApp(e1, e2) ->
      {ty1, ty2, ty3, ty4}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        ty1 == FUN(ty3, ty4),
        ty2 == ty3,
        ty == ty4

  | ExprIf(e1, e2, e3) ->
      {ty1, ty2, ty3}
        expr(s, e1, ty1),
        expr(s, e2, ty2),
        expr(s, e3, ty3),
        ty1 == BOOL(),
        ty2 == ty3,
        ty == ty2

  | ExprFun(d, e) ->
      {s_fun, ty1, ty2}
        new s_fun,
        s_fun -[ `LEX ]-> s,
        arg-decl(s_fun, d, ty1),
        expr(s_fun, e, ty2),
        ty == FUN(ty1, ty2)

  | ExprLet(bs, e) ->
      {s_last}
        seq-binds(s, bs, s_last),
        expr(s_last, e, ty)

  | ExprLetRec(bs, e) ->
      {s_let}
        new s_let,
        s_let -[ `LEX ]-> s,
        par-binds(s_let, bs, s_let),
        expr(s_let, e, ty)

  | ExprLetPar(bs, e) ->
      {s_let}
        new s_let,
        s_let -[ `LEX ]-> s,
        par-binds(s, bs, s_let),
        expr(s_let, e, ty)

}.



seq-binds(s, bs, s_last) :- bs match {
    
    SeqBindsNil()   ->
      new s_last,
      s_last -[ `LEX ]-> s
        
  | SeqBindsOne(b) ->
      new s_last,
      s_last -[ `LEX ]-> s,
      seq-bind(s, b, s_last)

  | SeqBindsCons(b, bs) ->
      {s_next}
        new s_next,
        s_next -[ `LEX ]-> s,
        seq-bind(s, b, s_next),
        seq-binds(s_next, bs, s_last)

}.



seq-bind(s, b, s_def) :- b match {
    
    DefBind(x, e) ->
      {s_dcl, ty}
        new s_dcl -> DatumVar(x, ty),
        s_def -[ `VAR ]-> s_dcl,
        expr(s, e, ty)
  
  | DefBindTyped(x, tyann, e) ->
      {s_dcl, ty1, ty2}
        new s_dcl -> DatumVar(x, ty1),
        s_def -[ `VAR ]-> s_dcl,
        type(s, tyann, ty1),
        expr(s, e, ty2),
        ty1 == ty2

}.



par-binds(s, bs, s_def) :- bs match {
    
    ParBindsNil() ->
      true
  
  | ParBindsCons(b, bs) ->
      par-bind(s, b, s_def),
      par-binds(s, bs, s_def)
  
}.



par-bind(s, b, s_def) :- b match {
    
    DefBind(x, e) ->
      {s_dcl, ty}
        new s_dcl -> DatumVar(x, ty),
        s_def -[ `VAR ]-> s_dcl,
        expr(s, e, ty)
  
  | DefBindTyped(x, tyann, e) ->
      {s_dcl, ty1, ty2}
        new s_dcl -> DatumVar(x, ty1),
        s_def -[ `VAR ]-> s_dcl,
        type(s, tyann, ty1),
        expr(s, e, ty2),
        ty1 == ty2

}.



arg-decl(s, d, ty) :- d match {

    ArgDecl(x, tyann) ->
      {s_dcl}
        type(s, tyann, ty),
        new s_dcl -> DatumVar(x, ty),
        s -[ `VAR ]-> s_dcl

}.



type(s, tyann, ty) :- tyann match {
    
    TInt() ->
        ty == INT()
  
  | TBool() ->
        ty == BOOL()
  
  | TArrow(tyann1, tyann2) ->
      {ty1, ty2}
        type(s, tyann1, ty1),
        type(s, tyann2, ty2),
        ty == FUN(ty1, ty2)

}.



mod-ref (s, r, s_def) :- r match {
    ModRef(x)  -> 
      {mods, xmods, xmods', p, x, s_mod}
        query s `LEX*`IMP?`MOD as mods,
        filter mods (DatumMod(x', _) where x' == x) xmods,
        min-refs(xmods, xmods'),
        only(xmods', p),
        tgt(p, s_res),
        s_def -[ `IMP ]-> s_res
    }.



var-ref(s, r, ty) :- r match {
    
    VarRef(name) ->
      {vars, xvars, xvars', p, s_res, d, x, res_ty}
        query s `LEX* `VAR as vars,
        filter vars (DatumVar(x', _) where x' == name) xvars,
        min-refs(xvars, xvars'),
        only(xvars', p),
        tgt(p, s_res),
        s_res -> DatumVar(x, res_ty)
        ty == res_ty
}.



// minimizing
min-refs(z, z') :-
  min z lexico(`VAR < `LEX) z'.

// s is the target scope of a path p
tgt(p,s) :- p match
  { End(x)       -> s == x
  | Edge(x,l,xs) -> tgt(xs,s)
  }.

// s is the source scope of a path p
src(p,s) :- p match
  { End(x)       -> s == x
  | Edge(x,l,xs) -> s == x
  }.